---
title: "codigo"
author: "ruben"
date: "2023-11-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

A lo largo de este documento se captura el procedimeinto segudo para tratar con el primer tipo de señales biomedicas
con las que trabajaremos a lo largo de nuestro proyecto, los ECG.

En nuestro caso, se ha decidido seguir la metodología CRISP-DM, dividiendo nuestro estudio en las siguientes fases

*   Comprensión del negocio y objetivo del estudio
*   Comprensión y análisis exploratorio de los datos 
*   Preprocesamiento del conjunto de datos
*   Implementación del modelo
*   Evaluación de los resultados



## Comprensión de los datos
Se ha realizado un estudio previo del funcionamiento de los mismos. De este, hemos extraido las siguientes conclusiones:

Un electrocardiograma es una prueba médica utilizada para evaluar la salud del corazón y diagnosticar problemas cardíacos. El corazón funciona como una bomba muscular, y su actividad eléctrica coordina la contracción de las distintas partes del músculo cardíaco. Este, en un estado normal tiene una frecuencia de bombeo de entre 60 y 100 pulsaciones por segundo, algo a tener en cuenta a lo largo de este cuaderno.

Cabe destacar que un electrocardiograma se divide en las siguientes partes:


[!Onda en un ECG]("./imagenes/ECG_parts.pgn")


Donde en P, se contraen las cavidades superiores del corazón, en QRS se contraen las inferiores y en T serecuperan las celulas del músculo cardíaco.

En este caso, el desafio presente consiste en el diagnóstico eficiente de anomalias en el pulso cardíaco atendiendo a la zona donde se produce el latido, siendo diagnosticables mediante el estudio de la onda del ECG, y que puede estar asociada a enfermedades, por lo tanto su detecctión es clave para la realización de un diagnóstico precozs. En este caso, los tipos de latidos son los siguientes:
*    Normal: son aquellos que siguen el ritmo cardíaco regular y se originan en el nodo sinusal, que es el marcapasos natural del corazón.
*   Supraventricular ectopic beat: en español      pueden estar asociados con arritmias supraventriculares como la fibrilación auricular.
*   Ventricular ectopic beat: o latidos ventriculares ectópicos pueden estar relacionados con arritmias ventriculares, como la taquicardia ventricular o la fibrilación ventricular.
*    Fusion beat: latidos de fusión pueden ocurrir en ciertas condiciones, como durante la estimulación eléctrica del corazón o en presencia de arritmias.



## Comprensión de los datos

Para nuestro estudio se toma como fuente de datos un fichero csv obtenido del sitio web del siguiente [enlace](https://www.kaggle.com/code/gregoiredc/arrhythmia-on-ecg-classification-using-cnn)
donde, en esta misma dirección se puede encontrar el significado de los metadatos proporcionados.

A partir del contenido del fichero se realiza en siguiente analisis exploratorio de los datos


```{r message=FALSE, warning=FALSE}
library(Rwave)
library(readr)
library(dplyr)
library(xgboost)
library(caret)
library(pROC)
library(ggplot2)
library(tidyr)
library(seewave)
```




```{r message=FALSE, warning=FALSE}

mitbih_train <- read_csv("data/mitbih_train.csv", 
    col_names = FALSE)
```


```{r warning=FALSE}
glimpse(mitbih_train)
```


Dado que la ultima columna, como se indica en la fuente de los datos, se corresponde con la clasificación de 
los datos, separamos por un lado esta de las series temporales que se corresponden con las frecuencias cardiacas,
almacenadas en el resto de las columnas.


```{r}

df <- mitbih_train[,1:187]
clases <- mitbih_train[,188]
clases <- clases[[1]]


table(clases)


```


Si se visualizan las clases en función de su aparición en el conjunto de datos, tenemos que se muestra una 
completa predominancia de los ECG donde el paciente no padece de ninguna enfermedad. La distribución de los valores se puede observar en el siguiente diagrama de sectores.

```{r}
etiquetas <- factor(x=clases,levels=c(0,1,2,3,4),labels = c("N","S","V","F","Unknown"))
pie(table(etiquetas))
```

En cuanto a las series temporales de cada una de las señales, se tiene que estas son de longitudes distintas, siendo su fin aquella columna a partir de la cual el resto de valores son 0. Para ello, generamos un conjunto de datos adicional donde a partir del fin de los mismos almacenamos un `NA` en lugar de un 0



Algunas primeras metricas de nuestro conjunto de datos para poder enterder comportamientos de cada uno de los tipos de 
señales son los siguientes:

*   Duración promedio: hay que tener en cuenta que todos no tienen la misma longitud, ya que se rellena con 0s a partir de donde faltan datos. Se crea un nuevo df cambiando estos 0s por NA

```{r eval=FALSE, include=FALSE}
df_NA <- df
for (i in 1:dim(df)[1]){
  df_NA[i,(max(which(df_NA[i,]!=0))+1):dim(df)[2]] <- NA
}
head(df_NA)

save(df_NA,file="vars.RData")
```

```{r}
load("vars.RData")
```


Omitiendo los NA para los calculos de longitud se tiene que:

```{r}
longitudes<-rowSums(!is.na(df_NA))
minimo<-min(longitudes)
maximo<-max(longitudes)
media<-mean(longitudes)
mediana<-median(longitudes)
desviacion<-sd(longitudes)

cat("El mínimo de las longitudes es: ",minimo,"\n \n")
cat("El máximo de las longitudes es: ",maximo,"\n \n")
cat("La media de las longitudes es: ",media,"\n \n")
cat("La mediana de las longitudes es: ",mediana,"\n \n")
cat("La desviación típica de las longitudes es: ",desviacion,"\n \n")
```

* Eliminación de los outliers en cuanto al tamaño de las ondas (con pocos valores)

```{r}
boxplot(longitudes)
a<-quantile(longitudes,0.25)
rango_IQR<-IQR(longitudes)
quitar<-a[[1]]-1.5*rango_IQR
cat("Quitamos los datos cuya longitud sea menor a ",quitar)
df_clean<-df_NA[longitudes>45,]
etiquetas <- etiquetas[longitudes>45]
```



La duración promedio general de nuestras señales es de `r mean(longitudes)` con una desviación típica de `r sd(longitudes)`. Además, la duración en función del tipo de onda es la siguiente:

```{r}
longitudes<-longitudes[longitudes>45]
valores_long = data.frame(l=longitudes,cl=etiquetas)

ggplot(data=valores_long, aes(x=l, y=l, fill=cl)) +
  geom_boxplot(color="black")
```


*   Distribuciones de las amplitudes

Las amplitures de las ondas siguen las siguientes distribuciones

```{r}
head(df_clean)
df_clean %>%
  mutate(etiquetas=etiquetas)%>%
  pivot_longer(cols=-etiquetas,names_to = "Elemento",values_to = "Valor")%>%
  ggplot(aes(x=etiquetas,y=Valor,fill=etiquetas))+
  geom_violin(color="black")
  
  
```

Con esto se puede observar que las distribuciones de las señales en función de su tipo son diferentes. Donde por ejemplo se destaca que la distribución de las ondas de ECG normales es más baja que para otro tipo de diagnósticos.

Por ultimo, se representa de forma grafica un ejemplo de cada uno

```{r}
elemN <- df_clean[1,]
elemS <- df_clean[which(etiquetas=="S")[1],]
elemV <- df_clean[which(etiquetas=="V")[1],]
elemF <- df_clean[which(etiquetas=="F")[1],]
elemQ <- df_clean[which(etiquetas=="Unknown")[1],]

par(mfrow=c(2,3))
plot(1:dim(elemN)[2],elemN,type="l",main="Onda normal",xlab="tiempo")
plot(1:dim(elemN)[2],elemS,type="l",main="Onda S",col ="skyblue",xlab="tiempo")
plot(1:dim(elemN)[2],elemV,type="l",main="Onda V",col ="pink",xlab="tiempo")
plot(1:dim(elemN)[2],elemF,type="l",main="Onda F",col="green",xlab="tiempo")
plot(1:dim(elemN)[2],elemQ,type="l",main="Onda desconocida",col="purple",xlab="tiempo")

```




#### Otras métricas estudiadas en la asignatura
Además de las características anteriores, se realiza un estudio de otro conjunto de métricas
Cabe destacar que sabemos que la frecuencia de muestreo del aparato es de 125Hzs.

Las seleccionadas para el tratamiento de nuestras señales han sido las siguientes:

*   Wavelets para la identificación de las partes de la onda

Realizando una pequeña busqueda previa, se tiene que la frecuencia de latidos promedio en señales Normales es cercana a los 100 latidos por minuto.
Además, la frecuencia de muestreo del aparato es de 125 Hzs. Sabiendo esto, para aplicar la transformada wavelet en nuestro porblema, como primera aproximación, se visualiza la función para cada tipo de onda de forma individual, usando para ello el tamaño de ventana inicial que cumple lo siguiente:

$$Periodo\_cardiaco (seg)= \frac{1}{125} = 0.008s$$

Vemos que entonces el tiempo de duración de nuestra onda es de:
$$\frac{187}{125} = 1.496$$
Es decir, un segundo y medio, aunque como la media de longitudes nos salía

Por ello, como primera ventana incial tomaremos una de prueba algo más del doble para evitar problemas de cara a captrar la señal, que en este caso será de 160


```{r}

fr <-125

elemN <- as.numeric(df_clean[1,])
elemN<-elemN[!is.na(elemN)]
elemS <- as.numeric(df_clean[which(etiquetas=="S")[1],])
elemS<-elemS[!is.na(elemS)]
elemV <- as.numeric(df_clean[which(etiquetas=="V")[1],])
elemV<-elemV[!is.na(elemV)]
elemF <- as.numeric(df_clean[which(etiquetas=="F")[1],])
elemF<-elemF[!is.na(elemF)]
elemQ <- as.numeric(df_clean[which(etiquetas=="Unknown")[1],])
elemQ<-elemQ[!is.na(elemQ)]

par(mfrow=c(2,3))
spectro(elemN,f=fr,wl=40,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda normal")
spectro(elemS,f=fr,wl=40,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda S")
spectro(elemV,f=fr,wl=40,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda V")
spectro(elemF,f=fr,wl=40,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda F")
spectro(elemQ,f=fr,wl=40,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda desconocida")
```

Probando con otros tamaños de pantalla se tiene que los resultados son:
```{r}

par(mfrow=c(2,3))
spectro(elemN,f=fr,wl=60,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda normal")
spectro(elemS,f=fr,wl=60,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda S")
spectro(elemV,f=fr,wl=60,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda V")
spectro(elemF,f=fr,wl=52,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda F")
spectro(elemQ,f=fr,wl=60,ovlp=50,wn="bartlett",scale=F,flog=T)
title("Onda desconocida")
```

Con esto se tiene que para al menos la primera onda de cada tipo, la frecuencia de la onda en sí parece de mayor frecuencia que en el resto de ondas.


* El espectro promedio de la onda es el siguiente: 

```{r}


par(mfrow=c(2,3))
meanspec(elemN,f=fr,wl=60,ovlp=20,wn="bartlett",scale=F,flog=T)
title("Onda normal")
meanspec(elemS,f=fr,wl=60,ovlp=20,wn="bartlett",scale=F,flog=T)
title("Onda S")
meanspec(elemV,f=fr,wl=60,ovlp=20,wn="bartlett",scale=F,flog=T)
title("Onda V")
meanspec(elemF,f=fr,wl=60,ovlp=20,wn="bartlett",scale=F,flog=T)
title("Onda F")
meanspec(elemQ,f=fr,wl=60,ovlp=20,wn="bartlett",scale=F,flog=T)
title("Onda desconocida")
```


Se replica el experimento con la transformada de gabor

```{r}

fr <-125


par(mfrow=c(2,3))
a<-cgt(elemN, 125, freqstep=.005, scale=25, plot=F)
image(Mod(a))
title("Onda normal")
a<-cgt(elemS, 125, freqstep=.005, scale=25, plot=F)
image(Mod(a))
title("Onda S")
a<-cgt(elemV, 125, freqstep=.005, scale=25, plot=F)
image(Mod(a))
title("Onda V")
a<-cgt(elemF, 125, freqstep=.005, scale=25, plot=F)
image(Mod(a))
title("Onda F")
a<-cgt(elemQ, 125, freqstep=.005, scale=25, plot=F)
image(Mod(a))
title("Onda desconocida")
```
A partir de esta, se pueden extraer los siguientes datos





Además, a partir de las ondas dadas podemos extraer el valor de su energia de la siguiente forma


```{r}
calcular_ste <- function(signal, tamano_ventana, solapamiento) {
  longitud_signal <- length(signal)
  energia_ste <- numeric(0)  # Vector para almacenar la energía STE
  
  # Iterar a través de la señal con solapamiento
  for (i in seq(1, longitud_signal - tamano_ventana + 1, by = solapamiento)) {
    ventana <- signal[i:(i + tamano_ventana - 1)]
    energia_segmento <- sum(ventana^2)
    energia_ste <- c(energia_ste, energia_segmento)
  }
  
  return(energia_ste)
}


ste_resultadoN <- calcular_ste(elemN, 10, 3)
ste_resultadoS <- calcular_ste(elemS, 10, 3)
ste_resultadoV <- calcular_ste(elemV, 10, 3)
ste_resultadoF <- calcular_ste(elemF, 10, 3)
ste_resultadoQ <- calcular_ste(elemQ, 10, 3)


par(mfrow=c(2,3))
plot(ste_resultadoN,type="l",col="pink")
plot(ste_resultadoS,type="l",col="skyblue")
plot(ste_resultadoV,type="l",col="green")
plot(ste_resultadoF,type="l",col="purple")
plot(ste_resultadoQ,type="l",col="orange")

```


*   Wavelets
Por ultimo se aplican las wavelets al problema en cuestión, que nos permitiran aislar las frecuencias del posible ruido de los electrocardiogramas junto con sus elementos básicos, P, QRS y T, explicados con anterioridad.



##  Preparación de los datos
Dado que implementaremos dos modelos diferences, como se verá en el siguiente apartado, y estos funcionan de forma ligeramente diferente, se generarán dos dataframes distintos para que se adapten a estos.
En ambos casos, en primera instancia se obtiene un conjunto de entrenamiento y de test balanceado, que permita obtener metricas de rendimiento de forma sencilla.

*   Primer dataframe: este se limita a almacenar las métricas extraibles de cada onda, omitiendo los valores en sí de esta onda en función del tiempo. Este se usa para alimentar un algormitmo de clasificación, que en este caso se ha decidido que sea `xgboost`

```{r}



mu_N <- sample(which(etiquetas=="N"),size = 50,replace = F)
mu_S <- sample(which(etiquetas=="S"),size = 50,replace = F)
mu_V <- sample(which(etiquetas=="V"),size = 50,replace = F)
mu_F <- sample(which(etiquetas=="F"),size = 50,replace = F)

train_N <- sample(mu_N,size = 40,replace = F)
test_N <-setdiff(mu_N,train_N)

train_S <- sample(mu_S,size = 40,replace = F)
test_S <-setdiff(mu_S,train_S)

train_V <- sample(mu_V,size = 40,replace = F)
test_V <-setdiff(mu_V,train_V)

train_F <- sample(mu_F,size = 40,replace = F)
test_F <-setdiff(mu_F,train_F)


train <- c(train_N,train_S,train_V,train_F)
test <- c(test_N,test_S,test_V,test_F)

df_train <- data.frame(id = train,clase=etiquetas[train])

```


Una vez lograda la separación, se inicia la extracción de características


```{r}
calcular_ste_id <- function(id, tamano_ventana, solapamiento) {
  signal <-unlist(df_clean[which(id==df_train[,1]),])
  longitud_signal <- length(signal)
  energia_ste <- numeric(0)  # Vector para almacenar la energía STE
  
  # Iterar a través de la señal con solapamiento
  for (i in seq(1, longitud_signal - tamano_ventana + 1, by = solapamiento)) {
    ventana <- signal[i:(i + tamano_ventana - 1)]
    energia_segmento <- sum(ventana^2)
    energia_ste <- c(energia_ste, energia_segmento)
  }
  
  return(energia_ste)
}

```


Adición de los variables seleccionadas, en este caso para capturar las energias
```{r}

df_train <-df_train %>%
  rowwise() %>%
  mutate(ener_media = mean(calcular_ste_id(id, 15, 3),na.rm=T),
         ener_50 = quantile(calcular_ste_id(id, 15, 3), 0.5,na.rm=T),
         ener_25 = quantile(calcular_ste_id(id, 15, 3), 0.25,na.rm=T),
         ener_75 = quantile(calcular_ste_id(id, 15, 3), 0.95,na.rm=T)) 

df_train %>% ggplot(aes(group=clase,y=ener_75))+
  geom_boxplot()

```

A continuación, se le añaden las variables relativas a la transformada de gabor

```{r}
gabor <- function(id,w){
  elem <- unlist(df_clean[which(id==df_train[,1]),])
  elem<-elem[!is.na(elem)]
  return(c(Mod(cgt(elem, w, freqstep=.005, scale=25, plot=FALSE))))
}


df_train <- df_train %>%
  rowwise() %>%
  mutate(gabor_media = mean(gabor(id, 20), na.rm=T),
         gabor_50 = quantile(gabor(id, 20), 0.5, na.rm=T),
         gabor_25 = quantile(gabor(id, 20), 0.55, na.rm=T),
         gabor_75 = quantile(gabor(id, 20), 0.85, na.rm=T))

df_train %>%ggplot(aes(group=clase,y=(ener_75-ener_25)))+
  geom_boxplot()

```




En cuanto a las caracteristicas extraidas para el entenamiento del modelo, las seleccionadas son las siguientes:

*   Tiempo de duración
*   Amplitud promedio
*   Rango intercuartílico
*   Cosas de frecuancuas me
*   Energia mediana de la onda
*   Energía máxima de la onda

#### Añadir las propias de los wavelet


*   Segundo dataframe: contiene los valores que toma en el tiempo la señal, además de una serie de características añadidas en las. Este alimentará el 

## Implementación del modelo

#### Primer modelo: XGBOOST
Antes de comenzar con el entrenamiento del modelo, se divide el conjunto de datos en train y test, de forma que pueda mantenerse un tratamiento honesto de los datos y evitar el suceso conocido como `fuga de datos`, que proporciona resultados irreales en nuestro modelo.

La proporción elegida en nuestro caso para el conjunto de entrenamiento ha sido del 80% de los datos.



```{r}
# Convert data to DMatrix format

train_col <- df_train$clase
df_t <- df_train[,-c(1,2)]

dtrain <- xgb.DMatrix(data = as.matrix(df_t), label = train_col)

# Set parameters for the XGBoost model
params <- list(
  objective = "multi:softmax",
  num_class = length(levels(train_col))
)

# Train the XGBoost model
xgb_model <- xgboost(data = dtrain, params = params, nrounds = 1)




```




```{r}

df_test <- data.frame(id = test,clase=etiquetas[test])

calcular_ste_id <- function(id, tamano_ventana, solapamiento) {
  signal <-unlist(df_clean[which(id==df_test[,1]),])
  longitud_signal <- length(signal)
  energia_ste <- numeric(0)  # Vector para almacenar la energía STE
  
  # Iterar a través de la señal con solapamiento
  for (i in seq(1, longitud_signal - tamano_ventana + 1, by = solapamiento)) {
    ventana <- signal[i:(i + tamano_ventana - 1)]
    energia_segmento <- sum(ventana^2)
    energia_ste <- c(energia_ste, energia_segmento)
  }
  
  return(energia_ste)
}

df_test <-df_test %>%
  rowwise() %>%
  mutate(ener_media = mean(calcular_ste_id(id, 15, 3), na.rm=T),
         ener_50 = quantile(calcular_ste_id(id, 15, 3), 0.5, na.rm=T),
         ener_25 = quantile(calcular_ste_id(id, 15, 3), 0.25, na.rm=T),
         ener_75 = quantile(calcular_ste_id(id, 15, 3), 0.95, na.rm=T)) 

gabor <- function(id,w){
  elem <- unlist(df[which(id==df_test[,1]),])
  return(c(Mod(cgt(elem, w, freqstep=.005, scale=25, plot=FALSE))))
}


df_test <- df_test %>%
  rowwise() %>%
  mutate(gabor_media = mean(gabor(id, 20)),
         gabor_50 = quantile(gabor(id, 20), 0.5),
         gabor_25 = quantile(gabor(id, 20), 0.55),
         gabor_75 = quantile(gabor(id, 20), 0.85))



```


```{r}

# Assuming df_test is your test dataset, and you've prepared it similarly to df_train
test_col <- df_test$clase
df_tst <- df_test[,-c(1,2)]

# Convert the test data to xgb.DMatrix format
dtest <- xgb.DMatrix(data = as.matrix(df_tst), label = test_col)

# Make predictions on the test set
predictions <- predict(xgb_model, dtest)

confusion_matrix <- table(Actual = test_col, Predicted = predictions)
print(confusion_matrix)

accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)
print(paste("Accuracy:", accuracy))

importance_matrix <- xgb.importance(model = xgb_model)
xgb.plot.importance(importance_matrix)
```


EN este caso, para nuestro conjunto de entrena


*   Implementación del segundo modelo
Esta se lleva a cabo en el fichero _x_, donde a partir de el segundo dataframe creado se implementa una red neuronal en python capaz de clasificar nuestras ondas.

## Evaluación de los resultados

#### Primer modelo

Dado que se tenia un conjunto desvalanceado, es importante seleccionar una metrica adecuada para evaluar los resultados
Como prmera aproximación usamos el accuracy, que aunque no cumpla con lo anterior nos servira para tomarla como referencia acerca del porcentaje total de instancias acertadas


```{r}
# Calculate accuracy
accuracy <- sum(diag(conf_matrix)) / sum(conf_matrix)
print(paste("Accuracy:", accuracy))
```

En cuanto a la tasa de aciertos en función de la clase se tiene la siguiente matriz de confusuón

```{r}
confusion_matrix <- table(Actual = y_test, Predicted = predictions + 1)
print(confusion_matrix)

```

En cuanto al area bajo la curva, que resuleve nuestro problema de desvalanceo, para el problema es 
la siguiente


```{r}
# Compute ROC curves for each class

roc_curves <- multiclass.roc(rownames(y_test_matrix), as.numeric(predictions), percent = TRUE)

# Plot ROC curves
plot(roc_curves, col = c("red", "green", "blue"), lty = 1:3, main = "Multi-Class ROC Curve", lwd = 2)
legend("right", legend = levels(y_test), col = c("red", "green", "blue"), lty = 1:3, lwd = 2)

```


#### Segundo modelo
La evaluación de los resultados, al igual que el entrenamiento del modelo, se ha llevado a cabo en el fichero _fichero_
